// Generated by CoffeeScript 2.4.1
(function() {
  'use strict';
  var CND, FS, IC, assign, badge, debug, declare, echo, help, info, inspect, isa, jr, local_methods, rpr, size_of, type_of, urge, validate, warn, whisper, xrpr;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'ICQL/MAIN';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  // PATH                      = require 'path'
  // PD                        = require 'pipedreams'
  // { $
  //   $async
  //   select }                = PD
  ({assign, jr} = CND);

  // #...........................................................................................................
  // join_path                 = ( P... ) -> PATH.resolve PATH.join P...
  // boolean_as_int            = ( x ) -> if x then 1 else 0
  ({inspect} = require('util'));

  xrpr = function(x) {
    return inspect(x, {
      colors: true,
      breakLength: 2e308,
      maxArrayLength: 2e308,
      depth: 2e308
    });
  };

  //...........................................................................................................
  FS = require('fs');

  IC = require('intercourse');

  //...........................................................................................................
  this.types = require('./types');

  ({isa, validate, declare, size_of, type_of} = this.types);

  //===========================================================================================================
  // LOCAL METHODS
  //-----------------------------------------------------------------------------------------------------------
  local_methods = {
    //---------------------------------------------------------------------------------------------------------
    limit: function*(me, n, iterator) {
      var count, x;
      count = 0;
      for (x of iterator) {
        if (count >= n) {
          return;
        }
        count += +1;
        yield x;
      }
    },
    //---------------------------------------------------------------------------------------------------------
    single_row: function(me, iterator) {
      var R;
      if ((R = this.first_row(iterator)) === void 0) {
        throw new Error("µ33833 expected at least one row, got none");
      }
      return R;
    },
    //---------------------------------------------------------------------------------------------------------
    all_first_values: function(me, iterator) {
      var R, key, row, value;
      R = [];
      for (row of iterator) {
        for (key in row) {
          value = row[key];
          R.push(value);
          break;
        }
      }
      return R;
    },
    //---------------------------------------------------------------------------------------------------------
    first_values: function*(me, iterator) {
      var R, key, row, value;
      R = [];
      for (row of iterator) {
        for (key in row) {
          value = row[key];
          yield value;
        }
      }
      return R;
    },
    //---------------------------------------------------------------------------------------------------------
    first_row: function(me, iterator) {
      var row;
      for (row of iterator) {
        return row;
      }
    },
    /* TAINT must ensure order of keys in row is same as order of fields in query */
    single_value: function(me, iterator) {
      var key, ref, value;
      ref = this.single_row(iterator);
      for (key in ref) {
        value = ref[key];
        return value;
      }
    },
    first_value: function(me, iterator) {
      var key, ref, value;
      ref = this.first_row(iterator);
      for (key in ref) {
        value = ref[key];
        return value;
      }
    },
    all_rows: function(me, iterator) {
      return [...iterator];
    },
    //---------------------------------------------------------------------------------------------------------
    query: function(me, sql, ...P) {
      var statement;
      statement = this.prepare(sql);
      return statement.iterate(...P);
    },
    //---------------------------------------------------------------------------------------------------------
    run: function(me, sql, ...P) {
      var statement;
      statement = this.prepare(sql);
      return statement.run(...P);
    },
    //---------------------------------------------------------------------------------------------------------
    _run_or_query: function(me, entry_type, is_last, sql, Q) {
      var returns_data, statement;
      statement = this.prepare(sql);
      returns_data = statement.reader;
      //.......................................................................................................
      /* Always use `run()` method if statement does not return data: */
      if (!returns_data) {
        if (Q != null) {
          return statement.run(Q);
        } else {
          return statement.run();
        }
      }
      //.......................................................................................................
      /* If statement does return data, consume iterator unless this is the last statement: */
      if ((entry_type === 'procedure') || (!is_last)) {
        if (Q != null) {
          return statement.all(Q);
        } else {
          return statement.all();
        }
      }
      //.......................................................................................................
      /* Return iterator: */
      if (Q != null) {
        return statement.iterate(Q);
      } else {
        return statement.iterate();
      }
    },
    //---------------------------------------------------------------------------------------------------------
    prepare: function(me, ...P) {
      return me.$.db.prepare(...P);
    },
    aggregate: function(me, ...P) {
      return me.$.db.aggregate(...P);
    },
    backup: function(me, ...P) {
      return me.$.db.backup(...P);
    },
    checkpoint: function(me, ...P) {
      return me.$.db.checkpoint(...P);
    },
    close: function(me, ...P) {
      return me.$.db.close(...P);
    },
    execute: function(me, ...P) {
      return me.$.db.exec(...P);
    },
    read: function(me, path) {
      return me.$.db.exec(FS.readFileSync(path, {
        encoding: 'utf-8'
      }));
    },
    function: function(me, ...P) {
      return me.$.db.function(...P);
    },
    load: function(me, ...P) {
      return me.$.db.loadExtension(...P);
    },
    pragma: function(me, ...P) {
      return me.$.db.pragma(...P);
    },
    transaction: function(me, ...P) {
      return me.$.db.transaction(...P);
    },
    //.........................................................................................................
    as_identifier: function(me, text) {
      return '"' + (text.replace(/"/g, '""')) + '"';
    },
    /* TAINT kludge: we sort by descending types so views, tables come before indexes (b/c you can't drop a
    primary key index in SQLite) */
    catalog: function(me) {
      return this.query("select * from sqlite_master order by type desc, name;");
    },
    //-----------------------------------------------------------------------------------------------------------
    type_of: function(me, name) {
      var ref, row;
      ref = me.$.catalog();
      for (row of ref) {
        if (row.name === name) {
          return row.type;
        }
      }
      return null;
    },
    //---------------------------------------------------------------------------------------------------------
    clear: function(me) {
      var count, i, len, name, ref, statement, type;
      count = 0;
      ref = this.all_rows(this.catalog());
      for (i = 0, len = ref.length; i < len; i++) {
        ({type, name} = ref[i]);
        statement = `drop ${type} if exists ${this.as_identifier(name)};`;
        me.$.execute(statement);
        count += +1;
      }
      return count;
    }
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.bind = function(settings) {
    var me;
    validate.icql_settings(settings);
    me = {
      $: {}
    };
    // me.$.settings = assign {}, settings
    this.connect(me, settings.connector, settings.db_path, settings.db_settings);
    this.definitions_from_path_sync(me, settings.icql_path);
    this.bind_definitions(me);
    me.icql_path = settings.icql_path;
    return me;
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT should check connector API compatibility */
  /* TAINT consider to use `new`-less call convention (should be possible acc. to bsql3 docs) */
  this.connect = function(me, connector, db_path, db_settings = {}) {
    if (me.$ == null) {
      me.$ = {};
    }
    me.$.db = new connector(db_path, db_settings);
    // me.$.dbr  = me.$.db
    // me.$.dbw  = new connector db_path, db_settings
    return me;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.definitions_from_path_sync = function(me, icql_path) {
    (me.$ != null ? me.$ : me.$ = {}).sql = IC.definitions_from_path_sync(icql_path);
    return me;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.bind_definitions = function(me) {
    var check_unique, ic_entry, local_method, name, ref;
    check_unique = function(name) {
      if (me[name] != null) {
        throw new Error(`µ11292 name collision: ${rpr(name)} already defined`);
      }
    };
    if (me.$ == null) {
      me.$ = {};
    }
//.........................................................................................................
    for (name in local_methods) {
      local_method = local_methods[name];
      (function(name, local_method) {
        var method;
        check_unique(name);
        local_method = local_method.bind(me.$);
        method = function(...P) {
          var error;
          try {
            return local_method(me, ...P);
          } catch (error1) {
            error = error1;
            warn(`when trying to call method ${name} with ${xrpr(P)}`);
            warn(`an error occurred: ${error.message}`);
            throw error;
          }
        };
        return me.$[name] = method.bind(me.$);
      })(name, local_method);
    }
    ref = me.$.sql;
    //.........................................................................................................
    for (name in ref) {
      ic_entry = ref[name];
      /* TAINT fix in intercourse */
      ic_entry.name = name;
      check_unique(name);
      me[name] = this._method_from_ic_entry(me, ic_entry);
    }
    //.........................................................................................................
    return me;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._method_from_ic_entry = function(me, ic_entry) {
    validate.ic_entry_type(ic_entry.type);
    //.........................................................................................................
    return (Q) => {
      var R, descriptor, i, idx, is_last, last_idx, len, part, ref;
      descriptor = this._descriptor_from_arguments(me, ic_entry, Q);
      last_idx = descriptor.parts.length - 1;
      ref = descriptor.parts;
      for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
        part = ref[idx];
        is_last = idx === last_idx;
        R = me.$._run_or_query(ic_entry.type, is_last, part, Q);
      }
      return R;
    };
  };

  //-----------------------------------------------------------------------------------------------------------
  this._descriptor_from_arguments = function(me, ic_entry, Q) {
    var R, is_void_signature, kenning, ref, signature;
    [signature, kenning] = IC.get_signature_and_kenning(Q);
    is_void_signature = kenning === '()' || kenning === 'null';
    if (is_void_signature) {
      R = (ref = ic_entry['()']) != null ? ref : ic_entry['null'];
    } else {
      R = ic_entry[kenning];
    }
    if (R == null) {
      R = ic_entry['null'];
    }
    //.........................................................................................................
    if (R == null) {
      throw new Error(`µ93832 calling method ${rpr(ic_entry.name)} with signature ${kenning} not implemented`);
    }
    return R;
  };

}).call(this);

//# sourceMappingURL=main.js.map
